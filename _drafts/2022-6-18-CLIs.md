---
layout: post
title: "Command Line Applications"
description: "<Description>"
toc: true
tags: 
- Python
- File I/O
- Shell Scripting
---

College passes by really fast and if you don't stop to document it, you will forget all the memories and things you are grateful for! Let's use the command line, a tool that you've been introduced to in your CS classes, as a place to keep track of things we are grateful for.

```python
print("Hello gratitude journal")
```
Hosted by: Drshika Asher

# Getting Ready

### Local Machine Instructions

1. Learn a bit of git on the command line. You can use any intro tutorial, but [this web browser one](https://learngitbranching.js.org/) looks good.

2. Go over the basics of test driven development with `pytest` in this tutorial on [our site](/testing101). Code along everything just to get an idea of why we test and how to create your workflow around tests. While I don't want all projects to have extensive tests (although it is a good habit), having even just 3-5 tests makes a huge difference.

3. Learn some basics of how a command line works. [Here is a quick crash course](https://www.vikingcodeschool.com/web-development-basics/a-command-line-crash-course) with links to resources to learn even more. The command line is intimidating, but once you get used to it, you'll wonder how you lived without it. It's part of almost every programmer's toolbox.

### Extras:

2. Learn a bit of git on the command line. You can use any intro tutorial, but [this web browser one](https://learngitbranching.js.org/) looks good.

3. Learn some basics of how a command line works. [Here is a quick crash course](https://www.vikingcodeschool.com/web-development-basics/a-command-line-crash-course) with links to resources to learn even more. The command line is intimidating, but you'll wonder how you lived without it once you get used to it. It's part of almost every programmer's toolbox.

# Workshop

In this course, we will build a Command Line app (CLI) that helps you be grateful every day. You will learn how to work with different Python Libraries, reading and writing from text and YAML files and taking user input. 

Prior Knowledge: Intermediate/Advanced Coding
Note: I've done this on MacOs Monterey 12.1 but you should be able to do this on any computer. Your progress shouldn't be drastically different, but you may need to adjust depending on how your OS does things. I used `python 3.9.9`.

# Background
## Libraries

Create a file called `requirements.txt` and fill it with this. This is a common convention in Python projects for listing all the libraries required.

```js
questionary
datetime
pyyaml
pyfiglet
plumbum
ruamel.yaml
```

Once you've saved this file, run the following to install them (if you use `python3` to execute commands, then use `pip3`):

```bash
$ pip install -r requirements.txt
[install output]
```

<details>
<summary>Note: for the code fences for terminal commands: </summary>
<br>
<code>
$ (this part is what you type)<br/>
(this part is the output)
</code>
</details>   

The `-r` flag tells `pip` to look at `requirements.txt` and install everything in it.

Let me explain how we're using each library.

* [questionary](https://github.com/tmbo/questionary) give us fancy interactive menu interfaces.
* [pyfiglet](https://github.com/pwaller/pyfiglet) provides ASCII art displays.
* [plumbum](https://plumbum.readthedocs.io/en/latest/) gives us a way of accepting input, displaying help information and calling existing system commands.
* [pyyaml](https://pyyaml.org/wiki/PyYAMLDocumentation) allows us to set a filepath and your name
* [datetime](https://pypi.org/project/DateTime/) gives us the date and time
* [ruaeml.yaml](https://pypi.org/project/ruamel.yaml/) extends capabilities of pyyaml and allows us to format strings properly

## What the code does

### Logical Level
Let's imagine this gratitude journal in real life. Here are some steps you may take:

1. Get a Journal
2. Open the Journal to the right page (for today)
3. Journal
4. Close the Journal
5. View past Journals

### Implementation
Now, here is the translation of those basic journal functionalities into code.

**Main Journal functions:**
1. `pick_journal`
    - Help the user get a journal with their name and store it in their location
2. `write_journal`
    - Open the right entry and allow the user to write what they are grateful for
3. `add_content`
    - Give the user a prompt to journal and collect their thoughts
4. `read_entries`
    - Let the user "flip" through their digital journal entries

### The Journal (`GJournal`) Class

Create a file called `journal.py`. We’ll use `cli` from the `plumbum` library to create the base template for our command line application.

```python
from plumbum import cli 

class GJournal(cli.Application):
    def main(self):
        print("Welcome to Fancy Gratitude Journal!")
if __name__ == "__main__":
    GJournal() 
```

When we run this using `python journal.py`, we get the following output:

```bash
    $ python journal.py
Welcome to Fancy Gratitude Journal!
```

The reason we have a __name__ == "__main__" condition is so we can choose to run our program in different ways. When running the program normally through Python, the condition will be true and the code inside will run, but in other cases it won’t.
# TODO: fix how this testing part is written
For example, if we want to write tests for our code (not covered in this tutorial but check out `_news/2020-05-16-testing101.md`), we would need to run the program in a different way.

### Provide help

Since you cannot see the full range of commands you can use in a CLI with neat little buttons, most CLI interfaces come with the `--help` or `-h` command. This command provides you the full range of flags or switches you can run a program with for different functionality. 

Let's see what we get out of the box for Plumbum. 

```bash
$ python journal.py --help
Usage:
    journal.py [SWITCHES]

Meta-switches:
    -h, --help         Prints this help message and quits
    --help-all         Prints help messages of all sub-commands and quits
    -v, --version      Prints the program's version and quits
```

Not a bad start. Now we should give our program a version number. In the real world, remember to change the version number as you add new changes so that people know when to update.

```python
from plumbum import cli 

class GJournal(cli.Application):
    VERSION = "0.0"

    def main(self):
        print("Hello World")
if __name__ == "__main__":
    GJournal()
```

This gets our version number display working nicely:

```bash
$ python journal.py --version
journal.py 1.3
$ python journal.py -h
journal.py 1.3

Usage:
    journal.py [SWITCHES]

Meta-switches:
    -h, --help         Prints this help message and quits
    --help-all         Prints help messages of all sub-commands and quits
    -v, --version      Prints the program's version and quits
```

### Pretty Graphics

We'll use `Figlet` from the `pyfiglet` library to make a fancy greeting for the user. I also chose to import `colors` from plumbum to get a custom color for the slanted font.

```python
from pyfiglet import Figlet
from plumbum import colors, cli 

def print_banner(text):
    with colors['LIGHT_SEA_GREEN']:
        print(Figlet(font='slant').renderText(text))

class GJournal(cli.Application):
    VERSION = "0.0"

    def main(self):
        print_banner("Gratitude Journal")

if __name__ == "__main__":
    GJournal()
```

Let's abstract this away into another function. In general, it's good practice to separate different functionality into separate helper functions so that you can test and debug it easily. The Main function doesn't care about how the fancy greeting is made, just that it is printed and shown to the user. 

### Saving the Journal

Now create another file called `config.yaml`. We will use this to store information about where your journal is persistently across different runs of the program.   

When you run the program, python collects your inputs and stores it in variables. If you don't save the data to an external file, that data will be lost and the next time you run your program it will go away. So we will use this file to store our configuration.

```yaml
   author: ""
   journal_name: ""
```
Here's what you should put for now.

### Creating the Journal

**Saving Configurations**

Since the information about our journal is encoded on this YAML file, we will need to create helper functions to load and unload from it. First let's create the `save_config()` helper function. It will take two parameters: `filename` and `config`. `config` will store the author and the foldername in the YAML format. `filename` is the YAML file you want to save your config to. 

```python
import yaml, ruamel.yaml

def save_config(filename, config):
    yaml = ruamel.yaml.YAML()

    with open(filename, "w") as file:
            yaml.dump(config, file)
```
We are also using a library called `ruamel.yaml` because it allows us to save the "" on the values in our dictionary. Otherwise we run into errors trying to change directories in later steps. 

To open a file for reading or writing (in this case we used the `w` for writing) you normally have to use an `open('filepath', 'w')` paired with a `file.close()` statement and handle any exceptions. By using the `with open(text file, 'w') as filename:` syntax, we can make our code cleaner and handle any exceptions that pop up.

While we're at it, let's also write out the code to load our data from the YAML file. Let's create two global variables to store the `author` and `journal_name` where we will be saving our entries. We're going to use the same with syntax that we discussed earlier, and assign our global variables to that of the YAML file.

```python
author = ""
journal_name = ""

def load_config(filename):
    global author, journal_name
    if not os.path.exists(filename):
        save_config(filename, {
            "author": '',
            "journal_name": ''
        })

    with open(filename, "r") as file:
        data = yaml.safe_load(file)
    author = data['author']
    journal_name = data['journal_name']
```

The first part checks if we already have a YAML file, and if we dont, creates it. The second part opens the file for reading (`r`) and loads the data from the YAML file into a dictionary. Then we assign the dictionary values into the global variables. 

**Create Journal Method**

Before we create our create_journal method, let's create a helper to make a folder. Now just in case we run into any errors during making the directory, we're going to add some print statements to check if it has been made. Wrap `os.makedirs(path)` in a try, except, else statement. We're going to **try** to make the directory but if it does not work, we will **except** an `OSError` and print out a message to the user using an fstring (read more about fstrings [here](https://www.geeksforgeeks.org/formatted-string-literals-f-strings-python/)). Once we make the folder, let's change directories into that folder and add a page. 

In the terminal, we can use `cd <folder name>` to change directories. But in python, we can use `os.chdir()` to go into our folder of choice. Likewise, we use `os.makedirs()` as the pythonic equivalent of `mkdir <folder name>`. 

```python
def init_folder(folder_name):
    try:
        os.makedirs(folder_name)
    except OSError:
        print(f"Creating the directory {folder_name} has failed.")

    os.chdir(journal_name)
    add_page()
```

Now let's create the function to actually make our journal. We need to get the `author` from the user to create a folder with the name: `journal_name` and then save our configuration into the YAML file. Then we call our helper to make the folder and add a page. Here's what it looks like in python:

```python
def create_journal():
    global author, journal_name
    author = ruamel.yaml.scalarstring.DoubleQuotedScalarString(questionary.text("What is your name?").ask())
    
    journal_name = ruamel.yaml.scalarstring.DoubleQuotedScalarString(author + "-Journal")

    my_dict = dict(author=author, journal_name=journal_name)

    save_config("config.yml", my_dict)
    init_folder(journal_name)
```

I'm using `ruamel.yaml.scalarstring.DoubleQuotedScalarString()` as a wrapper to make sure that double quotes are preserved. 

## Acknowledgements

Thank you so much for joining us for this workshop. Thanks to Harsh Deep & Monica Para (cofounder of 125 Summer of Side Projects: [https://125summer.tech/](https://125summer.tech/)) and [Candace Williams](https://medium.com/thebit/intro-to-file-i-o-and-terminal-usage-how-to-create-a-journal-using-python-7bf1ccf1549a) for a lot of language, explanations, and packages used to create this workshop. ILL!